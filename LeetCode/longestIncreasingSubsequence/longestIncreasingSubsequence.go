package longestIncreasingSubsequence

/*
 * [20,22,19,25,23,4,5,6,7]
 *
 *  想要用 DP 解，需要找到前後關係，當 f(n) 跳到 f(n+1) 時，需要知道 nums[n+1] 是否能接在 f(n) 紀錄的 memo 後面，
 *  舉例來說 f(2) 時 nums[1]=22 比 nums[0]=20 大，代表可以接。
 *  當遍歷的數 x 不大於 memo 的最後一個元素時，還是需要更新 memo，用二分法找到並取代滿足小於 x 的最大元素。
 *  注意我們到 f(6) 時，memo 為 [19,22,23] 且遍歷數為 4，而真正的解是 [20,22,25]，所以 memo 本來就不是正確排列，只確保長度，
 *  此時用二分查找把 19 取代為 4，因為 4 更有潛力接續更多尾數，可以看到 f(7) 時 5 能加入就是因為 f(6) 時有加入 4。
 *  你可能會疑惑，那麼 4 以前的可能性被抹殺了嗎？其實並沒有，如果我們把題目換成 [20,22,19,25,23,4,26,27]，那麼 memo 最後會變成 [4,22,23,26,27]，
 *  最佳解為 [20,22,23,26,27]，因為數列中沒有全部被取代 4 以後的值，我們看回原題的 f(8)，memo 為 [4,5,23] 且遍歷數為 7，
 *  在這一輪中 [4,5,23] 變成了 [4,5,7]，而 4 以前的數 [20,22,19,25,23] 的可能性也因此全被抹殺了，因為由 4 開始的長度已等同於歷史最大長度，且 4 最有可能往後接，
 *  就算出了比 4 前面還大的數 26，那也可以視為接在 4 後面。
 *
 * 1 [20]
 * 2 [20,22]
 * 3 [19,22]
 * 4 [19,22,25]
 * 5 [19,22,23]
 * 6 [4,22,23]
 * 7 [4,5,23]
 * 8 [4,5,6]
 * 9 [4,5,6,7]
 */
func lengthOfLIS(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	var memo = make([]int, 0, len(nums))
	memo = append(memo, nums[0])

	for i := 1; i < len(nums); i++ {
		if nums[i] > memo[len(memo)-1] {
			memo = append(memo, nums[i])
		} else {
			var l, r = 0, len(memo) - 1
			for l < r {
				mid := (l + r) / 2
				if memo[mid] < nums[i] {
					l = mid + 1
				} else {
					r = mid
				}
			}
			memo[r] = nums[i]
		}
	}
	return len(memo)
}
